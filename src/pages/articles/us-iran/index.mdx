---
title: 'Missed Opportunities'
slug: 'us-iran'
team:
    [
        { name: 'Bela Kurek', responsibility: 'UX' },
        { name: 'Florian Zia', responsibility: 'Development' },
        { name: 'Joshua Pachenco', responsibility: 'Project Management' },
        { name: 'Lukas Vogel', responsibility: 'Development' },
    ]
time: ['October 2018', 'Present']
description: 'Provide a way to explore and exchange information, to uncover missed opportunities in the Iran–US relationship.'
role: 'In this project, I was responsible for concept, the UX and the visual design.
This involved the circular visualization composition, fonts, colors, and spacing across the application.'
client: 'Massachusetts Institute of Technology'
coverImg: './images/cover.png'
priority: 2
---

import CustomImage from '$components/CustomImage'
import Carousel from '$components/Carousel'
import Gallery from '$components/Layout/Gallery'
import DataProvider from '$components/DataProvider'
import { graphql } from 'gatsby'

export const pageQuery = graphql`
    query GatsbyImageUsIran {
        ...ImagesUsIran
    }
`
// Cmment

# Introduction

One of the vexing issues besetting those active in international relations is the problem of knowledge — how much do we know about a particular situation, country, leader, movement, et cetera? Do we know enough to make good decisions? How confident are we about the information at hand? Who is providing that information? Do we have a grasp of what we do not know? The infamous “black swan” — an unexpected, damaging event — often results from the unknown. Arrogance about knowledge, particularly the belief that one need not know much about unfolding events, is another primary source of failure in global politics. The U.S.-Iran relationship has long been staggered by each party’s ignorance about the other. Missed opportunities rose not merely from bad luck but from knowing too little vital information about the other.

> » Missed opportunities rose not merely from bad luck but from knowing too little vital information about the other. «

# Outcome

<Carousel wrapper>
    <CustomImage imgSrc="main_view" description="Main timeline with spacing" />
    <CustomImage
        imgSrc="main_view__entity_hover"
        description="Hover state of an event or document"
    />
    <CustomImage
        imgSrc="detail_view__timeline_hover"
        description="Detail view of a single document"
    />
    <CustomImage
        imgSrc="detail_view__timeline_sentiment"
        description="Detail view with sentiment analysis"
    />
    <CustomImage
        imgSrc="detail_view__timeline_sentiment_compare"
        description="Compare view of sentiment analysis"
    />
</Carousel>

This project has attempted to address this knowledge gap through methods typically used by scholars and policy analysts, such as reading deeply into the history of each country’s foreign policy and relationship with each other. Critical oral history adds to conventional methods by encouraging decision makers to ponder how and why they responded to events and their counterparts. This enables some reflection that typically is not forthcoming in one-on-one interviews. The conferences, briefing documents, and scholars altogether encourage an unusual depth in considering events.

<Gallery>
    <CustomImage imgSrc="initial_sketches_1" />
    <CustomImage imgSrc="initial_sketches_2" />
    <CustomImage imgSrc="initial_sketches_3" />
</Gallery>

## Challenges

The emergence of GraphQL introduces a new era in web development. RESTful applications were the industry favorite for data transfers between client and server applications, but modern requirements have shifted. Applications have to deal with multiple clients--i.e. desktop, web, mobile, wearables--which are all interested in APIs exposed by server applications. The choice becomes one between using multiple client-specific APIs with REST, or just one API with GraphQL for all client applications, which hardly seems like a choice at all. GraphQL is more than just a unified interface, though; its ecosystem offers powerful capbilities and even more potential as its open source community grows.
For me, it was a lucky coincidence that a former coworker open-sourced the GraphQL implementation for Java. He worked to become one of GraphQL's first open source contributors, eventually creating one of the go-to implementations for Java. The experience shaped my own thinking about GraphQL, which was expanded when my employer evaluated GraphQL for their enterprise application. The glue between our client and server application was largely influenced by REST, but we had API endpoints for all our RESTful resources in place, eventually running into issues like Facebook for API-consuming client-dide applications. The API endpoints were too rigid, so they required aggregations and modifications. An aggregation means putting resources a singular API endpoint, where a modification is to offer variations of an API endpoint to request different representations of a resource. We introduced our own implementation to request resources from the server, and avoided modifying endpoints. But the aggregations were still in place, so we had our own naive implementation of GraphQL, though it was only able to query one resource and didn't understand relationships. From a client-side perspective, only Relay for React was as sophisticated a library in terms of consuming GraphQL APIs, so we invested time in this as well. In the end, GraphQL was too early in its development, so we postponed introducing it to our technology stack. Admittedly, none of us knew it would become so powerful or so popular.

This book starts with GraphQL in client-side applications, so you will use React as a UI library to consume your first third-party GraphQL API, which happens to be GitHub's GraphQL API. It is a popular choice among developers for a couple reasons: GitHub was one of few popular companies to releas a GraphQL API to the public; GitHub's subsequent growth has granted some credibility to GraphQL itself; and a third-party API usually focuses on client-side GraphQL in the beginning. This book teaches how to consume the GraphQL API into a client application without exposing it to the server.

When we shift gears toward GraphQL on the server side, we will implement a GraphQL API that can eventually be consumed into client-side operations. By the end, you should have a firm grasp about using GraphQL in almost all JavaScript applications. I say 'almost' because there are always new libraries, patterns, and best practices that need to be learned to keep up with emerging technology.

I sincerely hope this book provides an optimal learning experience for GraphQL. While you might not use React or Express daily, you should be able to apply these teachings in other solutions like Angular, Vue, Koa, or Hapi.
